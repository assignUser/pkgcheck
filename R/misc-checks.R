
#' Check whether all man files have been generated by 'roxygen2'
#'
#' @param path Path to local source repository
#' @return 'TRUE' if all files generated by 'roxygen2', otherwise 'FALSE'
#' @noRd
pkg_uses_roxygen2 <- function (path) {

    rd <- list.files (file.path (path, "man"),
                      pattern = "\\.Rd$",
                      full.names = TRUE)

    chk <- vapply (rd, function (i) {
                       l1 <- readLines (i, n = 1L, encoding = "UTF-8")
                       grepl ("Generated by roxygen2", l1, ignore.case = TRUE)
                       },
                       logical (1),
                       USE.NAMES = FALSE)

    return (all (chk))
}

#' Check whether package has 'contributing.md', as well as whether it has a
#' life cycle statement
#'
#' @inheritParams pkg_uses_roxygen2
#' @return Vector of two logical values, the first one identifying whether a
#' package has a 'contributing.md' file or not; the second whether this file has
#' a life cycle statement
#' @noRd
pkg_has_contrib_md <- function (path) {

    flist <- list.files (path,
                         all.files = TRUE,
                         recursive = TRUE,
                         full.names = TRUE)

    # contributing either with or without ".md" extension:
    ptn <- paste0 (.Platform$file.sep, "contributing", c ("$", "\\.md$"))
    f <- grep (paste0 (ptn, collapse = "|"), flist, ignore.case = TRUE)

    has_lifecycle <- FALSE
    if (length (f) == 1L) {

        contrib <- readLines (flist [f], encoding = "UTF-8")

        has_lifecycle <- any (grepl ("life\\s?cycle",
                                     contrib,
                                     ignore.case = TRUE))
    }

    return (c (has_contrib = length (f) == 1L,
               has_lifecycle = has_lifecycle))
}

#' Check whether a package has a `inst/CITATION` file
#'
#' This does no check the contents of that file in any way.
#' @noRd
pkg_has_citation <- function (path) {

    "CITATION" %in% list.files (file.path (path, "inst"))
}

#' Check whether a package has a `codemeta.json` file
#'
#' @noRd
pkg_has_codemeta <- function (path) {

    "codemeta.json" %in% list.files (path, recursive = FALSE)
}


get_Rd_meta <- utils::getFromNamespace (".Rd_get_metadata", "tools") # nolint


#' Check whether all functions have examples
#'
#' @inheritParams pkg_uses_roxygen2
#' @return Vector of named logical values, one for each '.Rd' file indicating
#' whether or not it has example lines.
#' @noRd
all_pkg_fns_have_exs <- function (path) {

    rd <- list.files (file.path (path, "man"),
                      pattern = "\\.Rd$",
                      full.names = TRUE)

    has_ex <- vapply (rd, function (i) {
                          rd_i <- tools::parse_Rd (i)
                          ex <- get_Rd_meta (rd_i, "examples")
                          length (ex) > 0
                      },
                      logical (1),
                      USE.NAMES = TRUE)

    names (has_ex) <-
        vapply (names (has_ex), function (i)
                utils::tail (strsplit (i, .Platform$file.sep) [[1]], 1),
                character (1))

    return (has_ex)
}

pkgname_available <- function (path) {

    desc <- data.frame (read.dcf (file.path (path, "DESCRIPTION")))
    pkg <- desc$Package

    pkg_grepped <- grep (.standard_regexps()$valid_package_name,
                         pkg,
                         value = TRUE)

    ap <- data.frame (utils::available.packages ())

    return (!pkg %in% ap$Package &
            pkg == pkg_grepped)
}

pkg_on_cran <- function (path) {

    desc <- data.frame (read.dcf (file.path (path, "DESCRIPTION")))
    pkg <- desc$Package

    ap <- data.frame (utils::available.packages ())
    res <- pkg %in% ap$Package

    if (res) {
        # Check whether CRAN package of that name has same title

        u <- paste0 ("https://cran.r-project.org/web/packages/",
                     pkg, "/index.html")
        x <- rvest::read_html (u)
        h2 <- paste0 (rvest::html_elements (x, "h2"))
        h2 <- gsub ("<h2>|<\\/h2>", "", h2)
        res <- grepl (desc$Title, h2, ignore.case = TRUE)
    }

    return (res)
}



#' CI results for GitHub only
#' @inheritParams pkg_uses_roxygen2
#' @return A 'data.frame' with one row for each GitHub workflow, and columns for
#' name, the 'conclusion' status, the git 'sha', and the date.
#' @noRd
ci_results_gh <- function (path) {

    d <- data.frame (read.dcf (file.path (path, "DESCRIPTION")))
    if (!"URL" %in% names (d))
        return ("Error: Description has no URL")

    u <- strsplit (d$URL, "\\s+") [[1]]
    u <- u [grep ("^https://github\\.com", u)]
    url <- strsplit (u, "\\/") [[1]]
    org <- utils::tail (url, 2) [1]
    repo <- utils::tail (url, 1)

    url <- paste0 ("https://api.github.com/repos/",
                   org,
                   "/",
                   repo,
                   "/actions/runs")

    runs <- httr::GET (url) %>% httr::content ()

    if (!"total_count" %in% names (runs))
        return (NULL)

    if (runs$total_count == 0)
        return (NULL)

    dat <- lapply (runs$workflow_runs, function (i) {
                       # in-progress runs have no conclusion entry:
                       concl <- i$conclusion
                       if (is.null (concl))
                           concl <- ""
                   data.frame (name = i$name,
                               status = i$status,
                               conclusion = concl,
                               sha = i$head_sha,
                               time = i$created_at)
                   })
    dat <- do.call (rbind, dat)
    dat$time <- strptime (dat$time, "%Y-%m-%dT%H:%M:%SZ")
    dat$time_dbl <- as.double (dat$time)
    # non-dply group_by %>% summarise:
    dat <- lapply (split (dat, f = as.factor (dat$name)),
                   function (i)
                       i [which.max (i$time_dbl), ])
    dat <- do.call (rbind, dat)

    dat$sha <- substring (dat$sha, 1, 6)
    dat$date <- strftime (dat$time, "%Y-%m-%d")
    rownames (dat) <- dat$time_dbl <- dat$time <- dat$status <- NULL

    return (dat)
}

#' Get all CI badges from a repository
#'
#' @param u URL of repo
#' @return Character vector of hyperlinked badge images
#' @noRd
ci_badges <- function (u) {

    orgrepo <- strsplit (u, "\\/") [[1]]
    org <- utils::tail (orgrepo, 2) [1]
    repo <- utils::tail (orgrepo, 1)
    # note: default branch is github only, so will only work if repo is also
    # mirrored on github!
    branch <- get_default_branch (org, repo)

    if (grepl ("github", u)) {

        u_readme <- paste0 ("https://raw.githubusercontent.com/",
                            org,
                            "/",
                            repo,
                            "/",
                            branch,
                            "/README.md")

    } else if (grepl ("gitlab", u)) {

        u_readme <- paste0 ("https://gitlab.com/",
                            org,
                            "/",
                            repo,
                            "/-/raw/",
                            branch,
                            "/README.md")
    }

    if (!url_exists (u_readme, quiet = TRUE))
        return (NULL)

    f <- tempfile (fileext = ".md")
    chk <- utils::download.file (u_readme, destfile = f, quiet = TRUE) # nolint
    readme <- readLines (f, encoding = "UTF-8")

    badges <- unlist (regmatches (readme,
                                  gregexpr ("https.*\\.svg", readme)))
    if (length (badges) == 0)
        return (NULL)
    platforms <- c ("github", "travis", "gitlab")
    badges <- badges [grep (paste0 (platforms, collapse = "|"),
                            badges)]
    for (p in platforms) {
        index <- grep (p, badges)
        p_u <- p
        if (p == "github") {
            wf_nms <- vapply (badges [index], function (i)
                              utils::tail (strsplit (i, "/") [[1]], 2) [1],
                              character (1),
                              USE.NAMES = FALSE)
            #p_u <- paste0 ("https://github.com/",
            #               org,
            #               "/",
            #               repo,
            #               "/actions/workflows/",
            #               wf_nms,
            #               ".yaml")
            p_u <- paste0 ("https://github.com/",
                           org,
                           "/",
                           repo,
                           "/actions")
        } else if (p == "travis") {

            p_u <- gsub ("\\.svg$", "", badges [index])
        }
        badges [index] <- paste0 ("[![",
                                  p,
                                  "](",
                                  badges [index],
                                  ")](",
                                  p_u,
                                  ")")
    }

    return (badges)
}

#' Check that left-assignment operators are used consistently throughout a
#' package. "LEFT_ASSIGN" tokens can also be `:=`, so these must also be
#' tallied, but are ignored.
#' Left-assign operators are: ("=", "<-", "<<-", ":=").
#' https://github.com/wch/r-source/blob/trunk/src/main/gram.y#L3283-L3290
#' https://github.com/wch/r-source/blob/trunk/src/main/gram.y#L3346-L3349
#' @inheritParams pkg_uses_roxygen2
#' @return Named vector of 2 values tallying instances of usage of `<-` and `=`.
#' @noRd
left_assign <- function (path) {

    rdir <- file.path (path, "R")
    if (!file.exists (rdir))
        return (c (":=" = 0L,
                   "<-" = 0L,
                   "<<-" = 0L,
                   "=" = 0L))

    rdir <- normalizePath (rdir)
    flist <- list.files (rdir,
                         full.names = TRUE,
                         pattern = "\\.q$|\\.r$|\\.s$",
                         ignore.case = TRUE)

    assigns <- vapply (flist, function (i) {
                           p <- tryCatch (utils::getParseData (parse (i)),
                                          error = function (e) NULL)
                           assigns <- c (":=" = 0L,
                                         "<-" = 0L,
                                         "<<-" = 0L,
                                         "=" = 0L)
                           if (is.null (p))
                               return (assigns)
                           la <- table (p$text [which (p$token ==
                                                       "LEFT_ASSIGN")])
                           if (":=" %in% names (la))
                               assigns [1] <- la [which (names (la) == ":=")]
                           if ("<-" %in% names (la))
                               assigns [2] <- la [which (names (la) == "<-")]
                           if ("<<-" %in% names (la))
                               assigns [3] <- la [which (names (la) == "<<-")]
                           if ("=" %in% names (la))
                               assigns [4] <- la [which (names (la) == "=")]

                           return (assigns)
                         },
                         integer (4),
                         USE.NAMES = TRUE)
    assigns <- rowSums (assigns)
    # rm `:=`:
    assigns <- assigns [which (!names (assigns) == ":=")]

    return (assigns)
}

#' Check whether the package contains any useless files like `.DS_Store`.
#' @inheritParams pkg_has_no_scrap
#' @return Names of any items which should not be present; otherwise an empty
#' character.
#' @noRd
pkg_has_scrap <- function (path) {

    # Have to tryCatch because gert errors anywhere other than a git repo. This
    # means scrap can only be detected in git repos.
    all_contents <- tryCatch (gert::git_ls ()$path,
                              error = function (e) NULL)

    if (is.null (all_contents))
        return (NULL)

    all_contents <- vapply (decompose_path (all_contents),
                            function (i) utils::tail (i, 1L),
                            character (1))

    scrap <- function() paste0 (c ("^\\.DS_Store$",
                                   "^Thumbs.db$",
                                   "^\\.vscode$",
                                   "\\.o$"),
                                collapse = "|")

    return (grep (scrap (), all_contents, value = TRUE))
}
